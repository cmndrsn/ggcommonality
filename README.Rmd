---
output: github_document
bibliography: references.bib
editor_options: 
  markdown: 
    wrap: 72
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ggcommonality <img src="man/ggcommonality_sticker.png" align="right"/>

<!-- badges: start -->

<!-- badges: end -->

ggcommonality creates bar plots of unique and joint effects from a
commonality analysis of a linear regression model. The S4 branch extends
its functionality using an object-oriented syntax. The package calls on
`yhat` to perform commonality analyses [@nimon2023r], building bar plots
in the style of those appearing in the [MAPLE
Lab's](https://maplelab.net) work applying commonality analysis to the
compositions of Bach and Chopin [@delle2025breaking;
@anderson2022exploring].

Partitions are plotted sequentially in alphabetical order, starting with
unique effects and are built iteratively with joint effects at higher
orders on top.

## Installation

You can install ggcommonality (under development) from
[GitHub](https://github.com/) with:

``` r
devtools::install_github("cmndrsn/ggcommonality", build_vignettes = TRUE, force = TRUE)
```

## Example

The function produces a GGCommonality object, containing ingredients for
plotting commonality effects, along with the results from the
commonality analysis.

```{r example, warning=FALSE}
library(ggcommonality)

my_formula <- mpg ~ wt + hp

p <- ggcommonality(formula = my_formula,
                   data = mtcars)
  
p |> attributes() |> summary()
```

ggcommonality objects can be defined, plotted, and summarized using
built-in methods.

```{r}
# visualize commonality effects and add confidence intervals
plot(p) +
  add_ci(p)
```

We can also check the results from `yhat`

```{r commonality, warning=FALSE}

get_yhat(p)
```

Commonality effects can be stacked in multiple ways:

```{r warning=FALSE}

# define object 
p <- ggcommonality(
  formula = my_formula,
  data = mtcars,
  stack = TRUE
)
  

# stack
plot(p) +
  add_ci(p)


```

```{r}
# define object 
p <- ggcommonality(
  formula = my_formula,
  data = mtcars,
  stack = TRUE, 
  stack_by = "partition"
)
  
# stack
plot(p) +
  add_ci(p)

```

The `bs_ci()` method prints confidence intervals generated for stacked
effects.

```{r}
bs_ci(p)
```

# Confidence intervals

The `resample_type` argument specifies whether to generate random-*x*,
confidence intervals, fixed-*x*, or wild-*x* confidence intervals. The
[appendices](https://www.john-fox.ca/Companion/) to @fox2018r summarizes
the advantages and disadvantages of fixed vs. random-*x* bootstrapping.
Wild-*x* provides a solution to fixed-*x* for models featuring
heteroscedasticity by multiplying re-sampled residuals with constants
sampled from a Gaussian distribution (`wild_type = "gaussian"`), or by
randomly multiplying half by 1 and half by -1 (`wild_type = "sign"`).

If `stack_by = "partition"`, confidence intervals represent the sum of
unique and joint effects for individual commonality partitions.
Otherwise, if `stack_by = "common"`, separate confidence intervals are
generated for the sum of unique effects and the sum of joint effects.

## Comparing confidence intervals

```{r warning=FALSE, message=FALSE}
# set r's random number generator
p1 <- ggcommonality(
  formula = my_formula,
  data = mtcars,
  resample_type = "fixed"
)
p2 <- ggcommonality(
  formula = my_formula,
  data = mtcars,
  resample_type = "wild"
)
  
library(patchwork)

# stack
plot(p1) +
  add_ci(p1)+
  ylim(0,0.65)+
  ggtitle("Fixed")|
  plot(p2) +
  add_ci(p2)+
    ylim(0,0.65)+
  ggtitle("Wild")

```

# Getting help

For additional details about on plotting with ggcommonality, see the 'Advanced ggcommonality' vignette:
```{r}
vignette('advanced-ggcommonality', 'ggcommonality')
```

You can also read the help documentation
`?ggcommonality()`, or [email Cameron
Anderson](mailto:andersoc@mcmaster.ca).

# References
